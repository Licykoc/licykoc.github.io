<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一些神奇的短文</title>
    <link href="/2333/08/05/dw/"/>
    <url>/2333/08/05/dw/</url>
    
    <content type="html"><![CDATA[<h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>如果26个英文字母</p><p>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p><p>分别等于:</p><p>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26</p><p>那么：</p><p><strong>Knowledge</strong> (知识):<br>K+N+O+W+L+E+D+G+E=11+14+15+23+12+5+4+7+5=<strong>96%</strong>。</p><p><strong>Workhard</strong> (努力工作）：<br>W+O+R+K+H+A+R+D＝ 23+15+18+11+8+1+18+4 =<strong>98%</strong>。</p><p>也就是说<strong>知识</strong>和<strong>努力工作</strong>对我们人生的影响可以达到<strong>96％</strong>和<strong>98％</strong>。</p><p><strong>Luck</strong>（好运） L+U+C+K＝12+21+3+11=<strong>47%</strong>。</p><p><strong>Love</strong>（爱情） L+O+V+E＝12+15+22+5=<strong>54%</strong>。</p><p><strong>看来，这些我们通常认为重要的东西却并没起到最重要的作用。</strong></p><h3 id="那么，什么可以决定我们100％的人生呢？"><a href="#那么，什么可以决定我们100％的人生呢？" class="headerlink" title="那么，什么可以决定我们100％的人生呢？"></a>那么，什么可以决定我们<strong>100％</strong>的人生呢？</h3><p>是<strong>Money</strong>金钱吗？</p><p>M+O+N+E+Y=13+15+14+5+25=<strong>72%</strong>。 看来也不是。</p><p>是<strong>Leadership</strong>领导能力吗？</p><p>L+E+A+D+E+R+S+H+I+P=12+5+1+4+5+18+19+9+16=<strong>89%</strong></p><p>还不是。</p><p><strong>金钱</strong> , <strong>权力</strong>也不能完全决定我们的生活。那是什么呢？</p><p>其实，真正能使我们生活圆满的东西就在我们的代码里面！</p><p><strong>iostream</strong>输入输出流所在的头文件</p><p>I+O+S+T+R+E+A+M=<br><strong>9+15+19+20+18+5+1+13=<br>100%</strong></p><p>所以坚持写代码吧……</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>你是否还记得，昔日的<strong>辉煌</strong>？</p><p>想当年，你仅靠一壶水，竟奇迹般地穿越了整个沙漠。</p><p>是什么，支持着你？</p><p>是它，——泰山。</p><p>你知道，只有登上泰山，五岳之尊，你才能蜕变，成为一个真正的勇士。</p><p>便是这黑暗中的一丝希望，便能成为你无穷的动力之源。</p><p>斩杀怪蜥，击退盗贼，只有你知道，这些力量来自何方。</p><p>最后的最后，你来到了这里。</p><p>你站在山下，仰望这座巍峨高耸的山脉，</p><p>从容地走上前去，写下四个大字：</p><h2 id="山前留名"><a href="#山前留名" class="headerlink" title="山前留名"></a>山前留名</h2><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><pre><code class="hljs armasm">大人们忙着去<span class="hljs-built_in">SB</span>（上班）<span class="hljs-comment">;</span>我呢，就来上网看看又有什么新消息在<span class="hljs-built_in">SB</span>（散播）<span class="hljs-comment">;</span>晚上,点菜的时候我说<span class="hljs-built_in">SB</span>（随便）<span class="hljs-comment">;</span>吃饱了到大街上<span class="hljs-built_in">SB</span>（散步）<span class="hljs-comment">;</span>回来手里就抓着<span class="hljs-built_in">SB</span>（鼠标）<span class="hljs-comment">;</span>有心情还去博客里写写<span class="hljs-built_in">SB</span>（随笔）<span class="hljs-comment">;</span>人，整天都在<span class="hljs-built_in">SB</span> !有幸碰到两美国美妞聊天，以为自己英文过关，但只听清一句话就是<span class="hljs-built_in">SB</span>（somebody = <span class="hljs-built_in">sb</span>.）<span class="hljs-comment">;</span>人活着可真<span class="hljs-built_in">SB</span>（失败）啊........那年我<span class="hljs-built_in">SB</span>（十八），到部队当<span class="hljs-built_in">SB</span>（士兵）。一开始，我当的是<span class="hljs-built_in">SB</span>（哨兵）。苦差事啊，看见<span class="hljs-built_in">SB</span>（上边）就要敬礼，一站几个钟头还不让看<span class="hljs-built_in">SB</span>（手表），屁大的事情都要及时<span class="hljs-built_in">SB</span>（上报），练站姿的时候还要挂个小<span class="hljs-built_in">SB</span>（沙包），一天下来，连<span class="hljs-built_in">SB</span>（散步）的力气也没有了。我就<span class="hljs-built_in">SB</span>（随便）编了个理由说我<span class="hljs-built_in">SB</span>（生病）想转去当<span class="hljs-built_in">SB</span>（水兵），结果被分到一个<span class="hljs-built_in">SB</span>（舢板）上，靠，就我那个<span class="hljs-built_in">SB</span>（身板），把我晕得呀，连上个月会餐吃的<span class="hljs-built_in">SB</span>（扇贝）、<span class="hljs-built_in">SB</span>（烧饼）都吐出来了，额滴神呀，我<span class="hljs-built_in">SB</span>（上辈）子做了什么孽啊。领导打算把我改去当<span class="hljs-built_in">SB</span>（伞兵），我说我不去，这要是着陆不小心，<span class="hljs-built_in">SB</span>（势必）就变成<span class="hljs-built_in">SB</span>（伤兵）了，要是<span class="hljs-built_in">SB</span>（手背）或者<span class="hljs-built_in">SB</span>（上臂）受伤裹上<span class="hljs-built_in">SB</span>（纱布），最多留个<span class="hljs-built_in">SB</span>（伤疤），要是腿摔断，可就变成<span class="hljs-built_in">SB</span>（孙膑）了，如果遇到<span class="hljs-built_in">SB</span>（山包）<span class="hljs-built_in">SB</span>（闪避）不及，那可真的<span class="hljs-built_in">SB</span>（折本）了。于是，我干脆<span class="hljs-built_in">SB</span>（收兵）不干了。当兵前后<span class="hljs-built_in">SB</span>（三百）天，除了累得脸<span class="hljs-built_in">SB</span>（刷白），什么也没有学到。去<span class="hljs-built_in">SB</span>（上班）吧？我念书的时候也不认真，从来不带<span class="hljs-built_in">SB</span>（书包）、不看<span class="hljs-built_in">SB</span>（书本），现在连<span class="hljs-built_in">SB</span>（鼠标）都不会用。只好去给人家看<span class="hljs-built_in">SB</span>（水泵），我连<span class="hljs-built_in">SB</span>（烧杯）都没有摸过，我哪懂？那个<span class="hljs-built_in">SB</span>（设备），没有说明、没有<span class="hljs-built_in">SB</span>（商标）也没有其它<span class="hljs-built_in">SB</span>（识别）标记，噪音的<span class="hljs-built_in">SB</span>（声波）在屋子里<span class="hljs-built_in">SB</span>（散播），象<span class="hljs-built_in">SB</span>（山崩）一样。突然，一个<span class="hljs-built_in">SB</span>（事变）发生了，我<span class="hljs-built_in">SB</span>（身边）的一块<span class="hljs-built_in">SB</span>（石板）突然倒下了</code></pre><h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p>李白：锦瑟无端五十弦，去年借我两万元 </p><p>杜甫：嫦娥应悔偷灵药，此事我咋不知道 </p><p>李白：重帏深下莫愁堂，你丫不要跟我装 </p><p>杜甫：秦时明月汉时关，陈年旧债已还完 </p><p>李白：万紫千红总是情，不还我钱真不行 </p><p>杜甫：春风又绿江南岸，我不还你怎么办 </p><p>李白：借问酒家何处有，不还我钱你是狗 </p><p>杜甫：烟笼寒水月笼沙，敢骂老子你王八</p><h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2><p>黑板上写着一道数学题：a&gt;0, a+1&lt;0 </p><p>数竞大神小A对信息学大佬小B说：“你连初中数学都没学过吗？原不等式组显然无解。”</p><p>小B拿起了一根粉笔，对小A微微一笑，转身在黑板上写下了：</p><p>a=2147483647。</p><h2 id="6"><a href="#6" class="headerlink" title="6."></a>6.</h2><pre><code class="hljs erlang">唧唧复唧唧，木兰开飞机， 开的什么机？波音<span class="hljs-number">747</span>！问女何所思，问女何所忆． 女亦有所思，没钱买飞机．昨夜见军帖，要用轰炸机， 飞机十二架，架架买不起．阿爷无大钱，木兰无金银， 愿去买钢铁，从此造飞机．东市买图纸，西市买螺丝， 南市买玻璃，北市买铁皮．旦辞爷娘去，暮宿旧机库， 不闻爷娘唤女声，但闻铁皮摩擦滋啦啦．旦辞机库去，暮至军营旁， 不闻爷娘唤女声，但闻将军大呼哈哈哈．万里开飞机，关山一下没． 热气传机翼，日光照玻璃．将军被吓死，壮士魂已飞．飞来撞天子，天子躺病床． 策勋十二转，赏赐俩耳光．可汗问所欲，木兰不愿进牢房； 愿开<span class="hljs-number">747</span>,飞着回故乡.爹娘闻女来,端起机关枪; 阿姊闻妹来,当户举手枪;小弟闻姊来,AK47推上膛. 开我机舱门,进我飞机舱,脱我战时袍,换上飞行装, 多装手榴弹,对外架机枪.出门埋炸弹,亲友皆惊忙: 离别十二年,不知木兰变态狂.疯子脚蹬地,呆子眼紧闭, 两人并排走,谁能说我不正常?</code></pre><h2 id="7"><a href="#7" class="headerlink" title="7."></a>7.</h2><p>班长说:走，我们去炸核弹基地。</p><p>副班长说:这个主意不错</p><p>化学课代表负责提取氢气</p><p>物理课代表负责拼装氢弹</p><p>数学课代表负责计算爆破面积</p><p>地理课代表负责策划爆破地点</p><p>信息课代表负责编写氢弹程序</p><p>历史课代表负责记录光辉场面</p><p>美术课代表负责描画壮观景致</p><p>生物课代表负责事后生态环境</p><p>政治课代表负责使用法律打官司</p><p>语文课代表负责乱写文章推卸责任</p><p>英语课代表到外国购买进口材料</p><p>体育课代表负责屠杀HLZ</p><p>轰隆一声响。。。。。。</p><h2 id="8"><a href="#8" class="headerlink" title="8."></a>8.</h2><p>ಠ.ಠ我有一个特异功能！！</p><p>ಠ.ರೃ取下一只眼睛~</p><p>ಠ.ಠ再装上去~</p><p>ರೃ.ಠ取下另一只~</p><p>ಠ.ಠ再装上去~</p><p>ರೃ.ರೃ两只都取下来~</p><p>ರೃ∀ರೃ装不上去了！！！</p><h2 id="9"><a href="#9" class="headerlink" title="9."></a>9.</h2><ul><li><p>西江月・证明</p></li><li><p>即得易见平凡，<br>仿照上例显然。</p></li><li><p>留作习题答案略，读者自证不难。</p></li><li><p>反之亦然同理，  推论自然成立。</p></li><li><p>略去过程 Q.E.D.， 由上可知证毕。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>选文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>本人刷题的网站</title>
    <link href="/2333/08/04/st/"/>
    <url>/2333/08/04/st/</url>
    
    <content type="html"><![CDATA[<h1 id="color-PINK-洛谷"><a href="#color-PINK-洛谷" class="headerlink" title="$\color{PINK}{洛谷}$"></a><a href="https://www.luogu.com.cn/" target="_blank" rel="noopener">$\color{PINK}{洛谷}$</a></h1><h1 id="color-RED-宁波OJ"><a href="#color-RED-宁波OJ" class="headerlink" title="$\color{RED}{宁波OJ}$"></a><a href="https://oj.nbdp.net/" target="_blank" rel="noopener">$\color{RED}{宁波OJ}$</a></h1><h1 id="color-BLUE-一本通"><a href="#color-BLUE-一本通" class="headerlink" title="$\color{BLUE}{一本通}$"></a><a href="http://ybt.ssoier.cn:8088/" target="_blank" rel="noopener">$\color{BLUE}{一本通}$</a></h1><h1 id="color-GREEN-JZXX-OJ"><a href="#color-GREEN-JZXX-OJ" class="headerlink" title="$\color{GREEN}{JZXX OJ}$"></a><a href="http://oj.jzxx.net/" target="_blank" rel="noopener">$\color{GREEN}{JZXX OJ}$</a></h1><h1 id="color-CYAN-Libre-OJ"><a href="#color-CYAN-Libre-OJ" class="headerlink" title="$\color{CYAN}{Libre OJ}$"></a><a href="https://loj.ac/" target="_blank" rel="noopener">$\color{CYAN}{Libre OJ}$</a></h1><h1 id="color-YELLOW-WANGANG-OJ"><a href="#color-YELLOW-WANGANG-OJ" class="headerlink" title="$\color{YELLOW}{WANGANG OJ}$"></a><a href="http://112.16.216.176:680/" target="_blank" rel="noopener">$\color{YELLOW}{WANGANG OJ}$</a></h1>]]></content>
    
    
    <categories>
      
      <category>选文</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法学习-图论最短路</title>
    <link href="/2020/06/11/xxTuLun/"/>
    <url>/2020/06/11/xxTuLun/</url>
    
    <content type="html"><![CDATA[<h2 id="这一周学习了最短路算法，特写此篇来温故"><a href="#这一周学习了最短路算法，特写此篇来温故" class="headerlink" title="这一周学习了最短路算法，特写此篇来温故"></a>这一周学习了<strong>最短路</strong>算法，特写此篇来温故</h2><h3 id="在最短路算法中，常见的有-Floyd-Dijkstra-Bellman-Ford-spfa"><a href="#在最短路算法中，常见的有-Floyd-Dijkstra-Bellman-Ford-spfa" class="headerlink" title="在最短路算法中，常见的有$Floyd , Dijkstra, Bellman-Ford , spfa$"></a>在最短路算法中，常见的有$Floyd , Dijkstra, Bellman-Ford , spfa$</h3><p>注 ：$spfa$算法是$Bellman-Ford$算法的队列优化版，故细讲$spfa$，而弃讲$Bellman-Ford$</p><h1 id="Floyd"><a href="#Floyd" class="headerlink" title="$Floyd$:"></a>$Floyd$:</h1><p>本算法适用于任意2点间的最短路径，可以处理有<code>负权值</code>的问题，但时间复杂度较高:$O(n^3)$</p><p>核心代码只有$4$行：</p><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> k:=<span class="hljs-number">1</span> to n do   <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>:=<span class="hljs-number">1</span> to n do     <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>:=<span class="hljs-number">1</span> to n do       f[<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>]:=<span class="hljs-built_in">min</span>(f[<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>],f[<span class="hljs-built_in">i</span>,k]+f[k,<span class="hljs-built_in">j</span>]);</code></pre><p>之后$f$数组$(i,j)=$$i$点至$j$点的最短路</p><h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="$Dijkstra$:"></a>$Dijkstra$:</h1><p>本算法可以解决单源最短路径，即一个起点，多个终点的最短路，不可处理<code>负权值</code>以及<code>负权回路</code>，时间复杂度$O(n^2)$</p><p>算法简介：使用$dis$数组记录源点至$i$的最短路径</p><p><a href="https://blog.csdn.net/lbperfect123/article/details/84281300" target="_blank" rel="noopener">算法详解</a></p><p><a href="https://www.luogu.com.cn/problem/P5767" target="_blank" rel="noopener">例题传送门</a></p><p><a href="https://licykoc.gitee.io/2020/06/10/lgP5768/" target="_blank" rel="noopener">例题详细题解</a></p><h1 id="spfa"><a href="#spfa" class="headerlink" title="$spfa$"></a>$spfa$</h1><p>本算法为$Bellman-Ford$的队列优化版，适用于单源最短路径，可处理<code>负权值</code>以及<code>负权回路</code>，时间复杂度$O(m)$</p><p>$Tips:spfa$算法可被毒瘤数据卡时间，使其退化为$O(nm)$</p><p><a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1382" target="_blank" rel="noopener">例题传送门</a></p><pre><code class="hljs gml"><span class="hljs-comment">/*</span><span class="hljs-comment">裸的spfa</span><span class="hljs-comment">*/</span>type node=record  t,ne:longint;  v:<span class="hljs-built_in">int64</span>;<span class="hljs-keyword">end</span>;<span class="hljs-keyword">var</span>  t,n,m,i,l,r:longint;  <span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>,z,k:<span class="hljs-built_in">int64</span>;  f:array[<span class="hljs-number">0.</span><span class="hljs-number">.2000000</span>] of node;  a,p:array[<span class="hljs-number">0.</span><span class="hljs-number">.200000</span>] of longint;  dis:array[<span class="hljs-number">0.</span><span class="hljs-number">.2000000</span>] of <span class="hljs-built_in">int64</span>;  v:array[<span class="hljs-number">0.</span><span class="hljs-number">.2000000</span>] of boolean;procedure add (<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>,z:longint);  <span class="hljs-keyword">begin</span>    inc(k);f[k].t:=<span class="hljs-symbol">y</span>; f[k].ne:=p[<span class="hljs-symbol">x</span>]; f[k].v:=z;p[<span class="hljs-symbol">x</span>]:=k;   <span class="hljs-keyword">end</span>;<span class="hljs-comment">//链式前向星存储方式</span><span class="hljs-keyword">begin</span>  read(n,m);  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> to m <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span> read(<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>,z); add(<span class="hljs-symbol">x</span>,<span class="hljs-symbol">y</span>,z); add(<span class="hljs-symbol">y</span>,<span class="hljs-symbol">x</span>,z); <span class="hljs-keyword">end</span>;  fillqword(dis,length(dis),maxlongint); dis[<span class="hljs-number">1</span>]:=<span class="hljs-number">0</span>;  l:=<span class="hljs-number">1</span>; r:=<span class="hljs-number">1</span>; a[l]:=<span class="hljs-number">1</span>; v[<span class="hljs-number">1</span>]:=<span class="hljs-literal">true</span>;    <span class="hljs-comment">//------------分割线 以下为spfa模板------------</span>    <span class="hljs-keyword">while</span> l&lt;=r <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span>    t:=a[l]; i:=p[t];<span class="hljs-keyword">while</span> i&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span>  k:=f[i].t;  <span class="hljs-keyword">if</span> dis[k]&gt;dis[t]+f[i].v <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span>      dis[k]:=dis[t]+f[i].v;          <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> v[k] <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> r:=r+<span class="hljs-number">1</span>; a[r]:=k; v[k]:=<span class="hljs-literal">true</span>; <span class="hljs-keyword">end</span>;        <span class="hljs-keyword">end</span>;  i:=f[i].ne;    <span class="hljs-keyword">end</span>;v[t]:=<span class="hljs-literal">false</span>; l:=l+<span class="hljs-number">1</span>;  <span class="hljs-keyword">end</span>;    write(dis[n]);<span class="hljs-keyword">end</span>.</code></pre><h1 id="全最短路算法对比："><a href="#全最短路算法对比：" class="headerlink" title="全最短路算法对比："></a>全最短路算法对比：</h1><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qplgsn06.png" srcset="/img/loading.gif" alt=""></p><h1 id="color-Gray-The-quad-end"><a href="#color-Gray-The-quad-end" class="headerlink" title="$\color{Gray}{The\quad end}$"></a>$\color{Gray}{The\quad end}$</h1>]]></content>
    
    
    <categories>
      
      <category>算法学习</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>洛谷-题解 P5767 【[NOI1997]最优乘车】</title>
    <link href="/2020/06/10/lgP5768/"/>
    <url>/2020/06/10/lgP5768/</url>
    
    <content type="html"><![CDATA[<p><strong>没有P党，赶紧来交个题解<del>水估值</del></strong></p><p>这题是个很好的最短路练手题，当然其他题解也有用<code>bfs</code>做的，不过本蒟蒻刚学<code>Dijkstra</code>,就用<code>Dijkstra</code>来做此题。</p><p>题目多读几遍就学会了如何建图，至于具体的话其他题解讲的也很细，可以去康康）。</p><p>本题的坑点就是输入，但<code>Pascal</code>语言可以很$Easy$的解决，<code>eoln</code>函数就是判断当前输入是否有换行,使用<code>not eoln</code>函数就可以将一整行的数字输入啦！</p><pre><code class="hljs pascal">j:=<span class="hljs-number">0</span>; <span class="hljs-comment">//读入指针</span><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> eoln <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span>   inc(j);  <span class="hljs-comment">//指针++</span>  <span class="hljs-keyword">read</span>(a[j]); <span class="hljs-comment">//读入</span><span class="hljs-keyword">end</span>;</code></pre><p>这样本题就没什么难点啦：</p><p>$Code:$</p><pre><code class="hljs pascal"><span class="hljs-keyword">uses</span> math;<span class="hljs-comment">//调用math库，包含了max,min等函数</span><span class="hljs-keyword">var</span>  i,j,k,n,m,l,t,g:longint;  v:<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">10000</span>] <span class="hljs-keyword">of</span> boolean; <span class="hljs-comment">//Dijkstra算法中判断已加入的端点数组</span>  f:<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">701</span>,<span class="hljs-number">0</span>..<span class="hljs-number">701</span>] <span class="hljs-keyword">of</span> longint; <span class="hljs-comment">//保存建图的数组</span>  dis,a:<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">10000</span>] <span class="hljs-keyword">of</span> longint; <span class="hljs-comment">//记录最后答案的数组</span><span class="hljs-keyword">begin</span>  readln(m,n);  filldword(f,length(f),maxlongint);  <span class="hljs-comment">//这个函数就是将f数组全置为maxlongint即2147483647</span>  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> m <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span>    j:=<span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> eoln <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span> inc(j); <span class="hljs-keyword">read</span>(a[j]); <span class="hljs-keyword">end</span>;<span class="hljs-keyword">for</span> k:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> j <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> t:=k+<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> j <span class="hljs-keyword">do</span>     f[a[k],a[t]]:=<span class="hljs-number">1</span>;readln;  <span class="hljs-keyword">end</span>;    <span class="hljs-comment">//以上为建图</span>    filldword(dis,length(dis),maxlongint);    <span class="hljs-comment">//接下来是Dijkstra算法的模板</span>  dis[<span class="hljs-number">1</span>]:=<span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n-<span class="hljs-number">1</span> <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span>    t:=maxlongint;<span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> v[j])<span class="hljs-keyword">and</span>(dis[j]&lt;t) <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> t:=dis[j]; g:=j; <span class="hljs-keyword">end</span>;v[g]:=true;<span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">not</span> v[j])<span class="hljs-keyword">and</span>(f[g,j]&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">then</span> dis[j]:=min(dis[j],dis[g]+f[g,j]);  <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">if</span> dis[n]=maxlongint <span class="hljs-keyword">then</span> <span class="hljs-keyword">write</span>(<span class="hljs-string">'NO'</span>) <span class="hljs-comment">//特判</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">write</span>(dis[n]-<span class="hljs-number">1</span>);<span class="hljs-keyword">end</span>.</code></pre>]]></content>
    
    
    <categories>
      
      <category>普及/提高-</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宁波-题解 P4740 4.清理垃圾(Pascal)</title>
    <link href="/2020/06/08/nbP4740/"/>
    <url>/2020/06/08/nbP4740/</url>
    
    <content type="html"><![CDATA[<h2 id="直接进入主题："><a href="#直接进入主题：" class="headerlink" title="直接进入主题："></a>直接进入主题：</h2><p>设<script type="math/tex">F[i,j]</script>=完成前<script type="math/tex">i</script>项任务，若小小桢桢花了j分钟，那么厅厅最少花<script type="math/tex">F[i,j]</script>分钟。</p><p>有以下动态方程：<br><strong>$F[i,j]=min(f[i-1,j]+b[i],f[i-1,j-a[i]])$</strong></p><h2 id="算法实现："><a href="#算法实现：" class="headerlink" title="算法实现："></a>算法实现：</h2><p>i从1枚举至n，j从0至5000<br>F数组一开始全设最大，特别的，F[0,0]=0<br>最后让i从0枚举5000：<br>  <code>for (int i=1;i&lt;=5000;++i) ans=min(ans,max(f[n,i],i))</code></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="hljs matlab">uses math;var  n,<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>,<span class="hljs-built_in">ans</span>:longint;  a,b:array[<span class="hljs-number">0.</span><span class="hljs-number">.100000</span>] of longint;  f:array[<span class="hljs-number">0.</span><span class="hljs-number">.1000</span>,<span class="hljs-number">0.</span><span class="hljs-number">.5000</span>] of integer;begin  read(n); <span class="hljs-built_in">ans</span>:=maxlongint;  <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>:=<span class="hljs-number">1</span> to n do read(a[<span class="hljs-built_in">i</span>]);   <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>:=<span class="hljs-number">1</span> to n do read(b[<span class="hljs-built_in">i</span>]);  fillchar(f,sizeof(f),<span class="hljs-number">127</span>);  f[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]:=<span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>:=<span class="hljs-number">1</span> to n do     <span class="hljs-keyword">for</span> <span class="hljs-built_in">j</span>:=<span class="hljs-number">0</span> to <span class="hljs-number">5000</span> do   <span class="hljs-keyword">if</span> <span class="hljs-built_in">j</span>&lt;a[<span class="hljs-built_in">i</span>] then f[<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>]:=f[<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>,<span class="hljs-built_in">j</span>]+b[<span class="hljs-built_in">i</span>] <span class="hljs-keyword">else</span> f[<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span>]:=<span class="hljs-built_in">min</span>(f[<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>,<span class="hljs-built_in">j</span>]+b[<span class="hljs-built_in">i</span>],f[<span class="hljs-built_in">i</span><span class="hljs-number">-1</span>,<span class="hljs-built_in">j</span>-a[<span class="hljs-built_in">i</span>]]);  <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>:=<span class="hljs-number">0</span> to <span class="hljs-number">5000</span> do <span class="hljs-built_in">ans</span>:=<span class="hljs-built_in">min</span>(<span class="hljs-built_in">ans</span>,<span class="hljs-built_in">max</span>(f[n,<span class="hljs-built_in">i</span>],<span class="hljs-built_in">i</span>));  write(<span class="hljs-built_in">ans</span>);<span class="hljs-keyword">end</span>.</code></pre>]]></content>
    
    
    <categories>
      
      <category>普及+/提高</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宁波-题解 P3835 4.沙盘游戏</title>
    <link href="/2020/06/08/nbP3835/"/>
    <url>/2020/06/08/nbP3835/</url>
    
    <content type="html"><![CDATA[<p><strong>这应该是绍兴2017的压轴题的了吧</strong><del>还是这么水</del></p><p><strong>进入正题</strong></p><h4 id="题目写这么长其实就是在一个n-m的矩阵里找最大子矩阵"><a href="#题目写这么长其实就是在一个n-m的矩阵里找最大子矩阵" class="headerlink" title="题目写这么长其实就是在一个n*m的矩阵里找最大子矩阵"></a>题目写这么长其实就是在一个n*m的矩阵里找最大子矩阵</h4><p>最大子矩阵嘛<br><del>看我直接o(n^6)暴力干他丫的</del></p><p>最朴素的做法是暴力枚举一个矩阵的左上角(a,b)，1&lt;=a&lt;=n,1&lt;=b&lt;=m<br>然后再暴力枚举矩阵的右下角(c,d),1&lt;=c&lt;=n,1&lt;=d&lt;=m 时间复杂度：o(n^6)<br>然后你可以获得30~40的<del>好</del>成绩</p><p>作为一个优秀的OI，你应该会想到用前缀和来优化此题，过于简单，o(n^4)<br>你可以获得60~80的好成绩</p><p>那么100pts的算法是啥呢?<br>没错，就是最大子段和！</p><p>一维的最大子段和很简单把：<br><pre><code class="hljs angelscript"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i) &#123;s=(s+a[i]&gt;<span class="hljs-number">0</span>)?s+a[i]:<span class="hljs-number">0</span>;<span class="hljs-comment">//三目运算符，等价于s+=a[i]; if (s&lt;0) s=0;</span>ans=max(ans,s);&#125;</code></pre></p><p>那么对于本题，二维的最大子矩阵和怎么做呢？<br>首先我们可以确定子矩阵的开始的行和结束的行<br>例子：<br><pre><code class="hljs angelscript"><span class="hljs-number">1</span>   <span class="hljs-number">2</span>   <span class="hljs-number">3</span><span class="hljs-number">3</span>  <span class="hljs-number">-5</span>   <span class="hljs-number">4</span><span class="hljs-number">3</span>   <span class="hljs-number">1</span>  <span class="hljs-number">-5</span> 对于这个矩阵，最大子矩阵左上角为(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),右下角为(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)即开始的行为<span class="hljs-number">1</span>，结束的行为<span class="hljs-number">2</span></code></pre><br>所以我们先枚举开始的行和结束的行:<br><pre><code class="hljs angelscript"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;++i)  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j=i;j&lt;=n;++j)&#123;  <span class="hljs-comment">/*</span><span class="hljs-comment"></span><span class="hljs-comment">*/</span>  &#125;</code></pre><br>然后对<strong>第i行至第j行的m个和</strong>进行最大子段和算法,从而算出整个矩阵的最大子矩阵和</p><pre><code class="hljs matlab"><span class="hljs-keyword">for</span> (int <span class="hljs-built_in">i</span>=<span class="hljs-number">1</span>;<span class="hljs-built_in">i</span>&lt;=n;++<span class="hljs-built_in">i</span>)  <span class="hljs-keyword">for</span> (int <span class="hljs-built_in">j</span>=<span class="hljs-built_in">i</span>;<span class="hljs-built_in">j</span>&lt;=n;++<span class="hljs-built_in">j</span>)&#123;  s=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> (int k=<span class="hljs-number">1</span>;k&lt;=n;++k)&#123;s=(s+第<span class="hljs-built_in">i</span>行至第<span class="hljs-built_in">j</span>行的第k个和&gt;<span class="hljs-number">0</span>)?s+第<span class="hljs-built_in">i</span>行至第<span class="hljs-built_in">j</span>行的第k个和:<span class="hljs-number">0</span>;<span class="hljs-built_in">ans</span>=<span class="hljs-built_in">max</span>(<span class="hljs-built_in">ans</span>,s);&#125;  &#125;</code></pre><p>最后<code>ans</code>即为答案，至于如何在o(1)算出<strong>第i行至第j行的第k个和</strong>，留给读者自行考虑</p>]]></content>
    
    
    <categories>
      
      <category>普及/提高-</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宁波-题解 P2508 [USACO 1.2.2]方块转换(Pascal)</title>
    <link href="/2020/06/08/nbP2508/"/>
    <url>/2020/06/08/nbP2508/</url>
    
    <content type="html"><![CDATA[<h2 id="啊这"><a href="#啊这" class="headerlink" title="啊这"></a>啊这</h2><p>这题是真的水<del>然鹅我码了1h</del><br>总结一下题意就是拿一个n*n的矩阵进行若干个操作可不可以变成目标矩阵<br>水是真的水，但是烦也是真的烦,还是看代码吧（防止抄袭，只展示部分）<br><pre><code class="hljs pascal"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">is</span>:</span>boolean; <span class="hljs-comment">//is函数用来判断当前矩阵和目标矩阵相不相同</span>  <span class="hljs-keyword">var</span>    i,j:longint;  <span class="hljs-keyword">begin</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>     <span class="hljs-keyword">if</span> t[i,j]&lt;&gt;map[i,j] <span class="hljs-keyword">then</span> <span class="hljs-keyword">exit</span>(false);<span class="hljs-comment">//t数组表示当前矩阵，map数组表示目标数组</span><span class="hljs-keyword">exit</span>(true);  <span class="hljs-keyword">end</span>;</code></pre><br><pre><code class="hljs pascal"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">g1</span>;</span><span class="hljs-comment">//第#1种交换</span>  <span class="hljs-keyword">var</span>    i,j:longint;  <span class="hljs-keyword">begin</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>     t[j,n-i+<span class="hljs-number">1</span>]:=a[i,j];<span class="hljs-comment">//a数组表示原始矩阵,t数组见上</span>  <span class="hljs-keyword">end</span>;</code></pre><br><pre><code class="hljs pascal"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">g2</span>;</span> <span class="hljs-comment">//第#2种交换</span>  <span class="hljs-keyword">var</span>    i,j:longint;  <span class="hljs-keyword">begin</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>     t[n-i+<span class="hljs-number">1</span>,n-j+<span class="hljs-number">1</span>]:=a[i,j];  <span class="hljs-keyword">end</span>;</code></pre><br><pre><code class="hljs pascal"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">g3</span>;</span><span class="hljs-comment">//第#3种交换</span>  <span class="hljs-keyword">var</span>    i,j:longint;  <span class="hljs-keyword">begin</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>     t[n-j+<span class="hljs-number">1</span>,i]:=a[i,j];  <span class="hljs-keyword">end</span>;</code></pre><br><pre><code class="hljs pascal"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">g4</span>;</span><span class="hljs-comment">//第#4种交换</span>  <span class="hljs-keyword">var</span>    i,j:longint;  <span class="hljs-keyword">begin</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>     __________;<span class="hljs-comment">//这句留给读者自行想象</span>  <span class="hljs-keyword">end</span>;</code></pre><br><pre><code class="hljs pascal"><span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">g5</span>;</span><span class="hljs-comment">//第#5种交换</span>  <span class="hljs-keyword">begin</span>     <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>     t[i,n-j+<span class="hljs-number">1</span>]:=a[i,j]; <span class="hljs-comment">//这里其实就是#4种交换</span>g:=t;<span class="hljs-comment">//g数组是临时数组，即仅保存当前t数组</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>     t[j,n-i+<span class="hljs-number">1</span>]:=g[i,j]; <span class="hljs-comment">//这里其实就是#1种交换</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> <span class="hljs-keyword">write</span>(<span class="hljs-number">5</span>); halt; <span class="hljs-keyword">end</span>; <span class="hljs-comment">//判断</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>     _____________; g:=t; <span class="hljs-comment">//这里留给读者自行想象</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>     _____________; <span class="hljs-comment">//这里留给读者自行想象</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> <span class="hljs-keyword">write</span>(<span class="hljs-number">5</span>); halt; <span class="hljs-keyword">end</span>;<span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>     _____________; g:=t; <span class="hljs-comment">//这里留给读者自行想象</span><span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>   <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>     _____________;  <span class="hljs-comment">//这里留给读者自行想象</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> <span class="hljs-keyword">write</span>(<span class="hljs-number">5</span>);  halt; <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">end</span>;</code></pre><br><pre><code class="hljs pascal"><span class="hljs-keyword">begin</span>  <span class="hljs-comment">&#123;读入矩阵，过于简单，不展示了&#125;</span>  g1; <span class="hljs-comment">//#1</span>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> <span class="hljs-keyword">write</span>(<span class="hljs-number">1</span>);  <span class="hljs-keyword">exit</span>; <span class="hljs-keyword">end</span>;  g2; <span class="hljs-comment">//#2</span>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> <span class="hljs-keyword">write</span>(<span class="hljs-number">2</span>);  <span class="hljs-keyword">exit</span>; <span class="hljs-keyword">end</span>;  g3; <span class="hljs-comment">//#3</span>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> <span class="hljs-keyword">write</span>(<span class="hljs-number">3</span>); <span class="hljs-keyword">exit</span>; <span class="hljs-keyword">end</span>;  g4; <span class="hljs-comment">//#4</span>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> <span class="hljs-keyword">write</span>(<span class="hljs-number">4</span>);  <span class="hljs-keyword">exit</span>; <span class="hljs-keyword">end</span>;  g5; <span class="hljs-comment">//#5</span>  t:=a; <span class="hljs-comment">//#6</span>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> <span class="hljs-keyword">write</span>(<span class="hljs-number">6</span>);  <span class="hljs-keyword">exit</span>; <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">write</span>(<span class="hljs-number">7</span>); <span class="hljs-comment">//最终无法交换输出7</span><span class="hljs-keyword">end</span>.</code></pre></p><h1 id="最后祝各位-包括我-2020CSP-RP"><a href="#最后祝各位-包括我-2020CSP-RP" class="headerlink" title="最后祝各位(包括我)2020CSP RP++"></a>最后祝各位(包括我)2020CSP RP++</h1>]]></content>
    
    
    <categories>
      
      <category>普及-</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宁波-题解 P4568 7、分割绳子(Pascal)</title>
    <link href="/2020/06/08/nbP4568/"/>
    <url>/2020/06/08/nbP4568/</url>
    
    <content type="html"><![CDATA[<h1 id="分割绳子"><a href="#分割绳子" class="headerlink" title="分割绳子"></a>分割绳子</h1><p>其实这道题是真的水，就是小数二分<del>然而我调了好久</del><br>暴力的话应该可以那个50pts?我没试过，但是应该很好想把</p><p>正解的二分其实也很水，我们先看看普通二分的模板:<br><pre><code class="hljs arduino">l=<span class="hljs-number">1</span>; r=<span class="hljs-built_in">max</span>;  <span class="hljs-keyword">while</span> l&lt;=r <span class="hljs-keyword">do</span> <span class="hljs-built_in">begin</span>   mid=(l+r) div <span class="hljs-number">2</span>;   <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">check</span><span class="hljs-params">(mid)</span> then l:</span>=mid+<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> r:=mid<span class="hljs-number">-1</span>; <span class="hljs-built_in">end</span>;<span class="hljs-built_in">write</span>(...);</code></pre><br>很简单吧，那换成小数怎么做呢？<br>其实也很简单<br>就是这一行 <code>while l&lt;=r do</code>改成<code>while (r-l)&gt;小数精度 do</code><br>就ok了</p><h2 id="好了进入本题"><a href="#好了进入本题" class="headerlink" title="好了进入本题"></a>好了进入本题</h2><p>题意很简单，n个木棍切成k个小段，求每个小段最长长度<br>不说别的了，上代码<br><pre><code class="hljs pascal"><span class="hljs-keyword">uses</span> math;<span class="hljs-keyword">var</span>  mid,l,r:extended;  n,k,i:longint;  a:<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">10000</span>] <span class="hljs-keyword">of</span> extended;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">check</span> <span class="hljs-params">(x:extended)</span>:</span>boolean; <span class="hljs-comment">//判断函数</span>  <span class="hljs-keyword">var</span> i:longint;  <span class="hljs-keyword">begin</span>    s:=<span class="hljs-number">0</span>;<span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span> s:=s+trunc(a[i]/x);<span class="hljs-keyword">if</span> s&gt;=k <span class="hljs-keyword">then</span> <span class="hljs-keyword">exit</span>(true) <span class="hljs-keyword">else</span> <span class="hljs-keyword">exit</span>(false);<span class="hljs-comment">// s&gt;=k 想想看是什么意思</span>  <span class="hljs-keyword">end</span>;<span class="hljs-keyword">begin</span>  <span class="hljs-keyword">read</span>(n,k);  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span> <span class="hljs-keyword">read</span>(a[i]); r:=max(r,a[i]); <span class="hljs-keyword">end</span>;   <span class="hljs-comment">//取r的范围</span>  l:=<span class="hljs-number">1</span>; r:=trunc(r)+<span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span> (r-l)&gt;<span class="hljs-number">0.001</span> <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span>   <span class="hljs-comment">//二分模板</span>    mid:=(l+r)/<span class="hljs-number">2</span>;<span class="hljs-keyword">if</span> check(mid) <span class="hljs-keyword">then</span> l:=mid+<span class="hljs-number">0.0001</span> <span class="hljs-keyword">else</span> r:=mid-<span class="hljs-number">0.0001</span>;  <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">write</span>(l:<span class="hljs-number">0</span>:<span class="hljs-number">2</span>); <span class="hljs-comment">//输出</span><span class="hljs-keyword">end</span>.</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>普及-</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>洛谷-题解 P6188 【[NOI Online 入门组]文具订购（民间数据）】</title>
    <link href="/2020/06/07/lgP6188/"/>
    <url>/2020/06/07/lgP6188/</url>
    
    <content type="html"><![CDATA[<h2 id="蒟蒻来发题解啦"><a href="#蒟蒻来发题解啦" class="headerlink" title="蒟蒻来发题解啦"></a>蒟蒻来发题解啦</h2><p><del>本蒟蒻康不懂上面大佬的方法</del></p><p>其实这道题用纯暴力也是可以水过去的 awa</p><p>详见下方注释</p><pre><code class="hljs pascal"><span class="hljs-keyword">uses</span> math;<span class="hljs-keyword">var</span>  n,a,b,c,ma,mb,mc,tt:longint; <span class="hljs-comment">//ma,mb,mc是储存最优解的变量，tt是有没有答案的标记</span><span class="hljs-keyword">begin</span>  readln(n);  <span class="hljs-comment">//输入</span>  <span class="hljs-keyword">if</span> (n <span class="hljs-keyword">mod</span> <span class="hljs-number">14</span>)=<span class="hljs-number">0</span> <span class="hljs-keyword">then</span>  <span class="hljs-comment">//特判，是14的倍数直接输出</span>    <span class="hljs-keyword">begin</span>      <span class="hljs-keyword">write</span>(n <span class="hljs-keyword">div</span> <span class="hljs-number">14</span>,<span class="hljs-string">' '</span>,n <span class="hljs-keyword">div</span> <span class="hljs-number">14</span>,<span class="hljs-string">' '</span>,n <span class="hljs-keyword">div</span> <span class="hljs-number">14</span>);       halt;    <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">for</span> a:=n <span class="hljs-keyword">div</span> <span class="hljs-number">7</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span> <span class="hljs-keyword">do</span>  <span class="hljs-comment">//暴力枚举圆规的个数</span>    <span class="hljs-keyword">for</span> b:=(n-a*<span class="hljs-number">7</span>)&gt;&gt;<span class="hljs-number">2</span> <span class="hljs-keyword">downto</span> <span class="hljs-number">0</span> <span class="hljs-keyword">do</span>  <span class="hljs-comment">//暴力枚举笔的个数 Ps：&gt;&gt;2是位运算，等同于 div 4，但是更快 </span>  <span class="hljs-keyword">begin</span>    c:=(n-a*<span class="hljs-number">7</span>-b*<span class="hljs-number">4</span>) <span class="hljs-keyword">div</span> <span class="hljs-number">3</span>; <span class="hljs-comment">//省略第三重循环，直接算笔记本的个数</span><span class="hljs-keyword">if</span> a*<span class="hljs-number">7</span>+b&lt;&lt;<span class="hljs-number">2</span>+c*<span class="hljs-number">3</span>=n <span class="hljs-keyword">then</span>  <span class="hljs-comment">//如果可以用完n元钱，Ps: &lt;&lt;2也是位运算，等同于 *4</span>  <span class="hljs-keyword">begin</span>    <span class="hljs-keyword">if</span> min(a,min(b,c))&gt;=min(ma,min(mb,mc)) <span class="hljs-keyword">then</span> <span class="hljs-comment">//题目要求的第2条，3个个数中最小的最大</span>  <span class="hljs-keyword">if</span> a+b+c&gt;=ma+mb+mc <span class="hljs-keyword">then</span> <span class="hljs-comment">//题目要求的第3条，总和最大</span>    <span class="hljs-keyword">begin</span> tt:=<span class="hljs-number">1</span>; ma:=a; mb:=b; mc:=c; <span class="hljs-keyword">end</span>; <span class="hljs-comment">//记录当前答案，并更新tt为1</span>  <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">if</span> tt=<span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">write</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">//若没有答案，输出-1</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">write</span>(ma,<span class="hljs-string">' '</span>,mb,<span class="hljs-string">' '</span>,mc);  <span class="hljs-comment">//输入</span><span class="hljs-keyword">end</span>. <span class="hljs-comment">//完结撒花awa</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>普及/提高-</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>洛谷-P6547 [COCI2010-2011#2] NAPOR 题解</title>
    <link href="/2020/06/07/lgP6547/"/>
    <url>/2020/06/07/lgP6547/</url>
    
    <content type="html"><![CDATA[<p>发现没有<strong>Pascal</strong>的题解，赶紧来水一发</p><p>题目大致意思就是<strong>从$n$个字符串里找到用非数字符号分隔开的每个数字并排序</strong></p><p>从字符串中找数字的话，可以使用<strong>最长平台</strong>（假的）来实现</p><pre><code class="hljs pascal"><span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> length(s) <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> s[j] <span class="hljs-keyword">in</span> [<span class="hljs-string">'0'</span>..<span class="hljs-string">'9'</span>] <span class="hljs-keyword">then</span> z:=z+s[j]<span class="hljs-comment">//类似最长平台的算法</span> <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>  <span class="hljs-keyword">if</span> z=<span class="hljs-string">''</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//如果是空串，那么跳过</span>   <span class="hljs-keyword">while</span> (z[<span class="hljs-number">1</span>]=<span class="hljs-string">'0'</span>) <span class="hljs-keyword">do</span> delete(z,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//如果有前缀0，去除</span>           inc(tot); a[tot]:=z;chen<span class="hljs-comment">//存入数组</span>   z:=<span class="hljs-string">''</span>; <span class="hljs-keyword">end</span>;</code></pre><p>打完上面的代码后，本题就基本$ok$了，但还有一点细节</p><h2 id="细节1"><a href="#细节1" class="headerlink" title="细节1:"></a><strong>细节1:</strong></h2><p><strong>在处理前缀0时，要防止只有一个数字$0$的时候，所以要加特判</strong></p><p><code>while (z[1]=&#39;0&#39;) do delete(z,1,1);</code></p><p><strong>变成</strong></p><p><code>while (z[1]=&#39;0&#39;)and(z&lt;&gt;&#39;0&#39;) do delete(z,1,1);</code></p><h2 id="细节2"><a href="#细节2" class="headerlink" title="细节2:"></a><strong>细节2:</strong></h2><p><strong>存数要用高精度存，毕竟题目所说有100位的整数呢</strong></p><h2 id="细节3"><a href="#细节3" class="headerlink" title="细节3:"></a><strong>细节3:</strong></h2><p> <strong>既然要用高精度存，那么在对数组排序时需要用字符串的比较方式：</strong><br><code>( length(a) &lt; length(b) ) or ( length(a) = lengt(b) ) and ( a &lt; b  )</code></p><p>到这里，本题就<strong>AC</strong>啦</p><p>下面是代码君:</p><pre><code class="hljs pascal"> <span class="hljs-keyword">var</span>  z,s,t:ansistring;  n,i,j,tot:longint;  a:<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">500</span>] <span class="hljs-keyword">of</span> ansistring;<span class="hljs-keyword">begin</span>  readln(n);  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span>    readln(s); s:=s+<span class="hljs-string">' '</span>; z:=<span class="hljs-string">''</span>;<span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> length(s) <span class="hljs-keyword">do</span>  <span class="hljs-keyword">if</span> s[j] <span class="hljs-keyword">in</span> [<span class="hljs-string">'0'</span>..<span class="hljs-string">'9'</span>] <span class="hljs-keyword">then</span> z:=z+s[j]    <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>  <span class="hljs-keyword">if</span> z=<span class="hljs-string">''</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">continue</span>;  <span class="hljs-keyword">while</span> (z[<span class="hljs-number">1</span>]=<span class="hljs-string">'0'</span>)<span class="hljs-keyword">and</span>(z&lt;&gt;<span class="hljs-string">'0'</span>) <span class="hljs-keyword">do</span> delete(z,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);  inc(tot); a[tot]:=z;  z:=<span class="hljs-string">''</span>;<span class="hljs-keyword">end</span>;  <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> tot-<span class="hljs-number">1</span> <span class="hljs-keyword">do</span>    <span class="hljs-keyword">for</span> j:=i+<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> tot <span class="hljs-keyword">do</span>      <span class="hljs-keyword">if</span> (length(a[i])&gt;length(a[j]))<span class="hljs-keyword">or</span>((length(a[i])=length(a[j]))<span class="hljs-keyword">and</span>(a[i]&gt;a[j])) <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span>   t:=a[i]; a[i]:=a[j]; a[j]:=t; <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> tot <span class="hljs-keyword">do</span> writeln(a[i]);<span class="hljs-keyword">end</span>.</code></pre>]]></content>
    
    
    <categories>
      
      <category>普及-</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>洛谷-题解 P6581 【远大目标】</title>
    <link href="/2020/06/07/lgP6581/"/>
    <url>/2020/06/07/lgP6581/</url>
    
    <content type="html"><![CDATA[<p>发现没人用<code>Python</code>，赶紧来水一发</p><h2 id="题意："><a href="#题意：" class="headerlink" title="题意："></a>题意：</h2><p>对于每一个$n(1 \le n \le 2^{63}-1)$,输出$n*2-1$</p><p>如果$n \le 0$时，输出$0$</p><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>最大的$n$已经到了$2^{63}-1$,普通的<code>long long</code>会爆，用<code>unsigned long long</code>即可</p><p>但本蒟蒻<del>过于懒蛋</del>，使用”高精度杀手<code>Python</code>“来切此题:</p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code class="hljs python">n = int(input())<span class="hljs-keyword">if</span> (n&lt;=<span class="hljs-number">0</span>) :    print(<span class="hljs-number">0</span>)<span class="hljs-keyword">else</span> :    print(n * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>)</code></pre><p><del>短小精悍</del></p>]]></content>
    
    
    <categories>
      
      <category>普及-</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宁波-题解 P1348 4.传话游戏(Pascal)</title>
    <link href="/2020/06/06/nbP1348/"/>
    <url>/2020/06/06/nbP1348/</url>
    
    <content type="html"><![CDATA[<p><strong>说实话这道题很简单</strong></p><p><strong>学过一点点图论的人都知道可以用floyd算法</strong></p><pre><code class="hljs cpp">f[i][j] = f[i][j] || f[i][k] &amp;&amp; f[k][j] <span class="hljs-comment">//floyd核心部分</span></code></pre><p><strong>但是floyd算法的时间复杂度为o(n^3)，对于本题的n=1000是过不掉的</strong></p><p><strong>所以本题正解为<a href="https://blog.csdn.net/cax1165/article/details/51864105" target="_blank" rel="noopener" title="Tarjan">Tarjan</a>算法</strong></p><p><strong>然鹅因为<del>本人过于蒟蒻</del>码量太大，我不打算用Tarjan算法</strong></p><p><strong>既然普通的floyd过不了的话，就<del>开氧气</del>使用奇技淫巧，强行优化</strong></p><p><strong>在仔细研究floyd核心程序段时，可以发现在</strong><br><pre><code class="hljs delpphi">for k:&#x3D;1 to n do  for i:&#x3D;1 to n do  for j:&#x3D;1 to n do &#x2F;&#x2F;这一层循环   f[i,j]:&#x3D;f[i,j] or (f[i,k] and f[k,j]);</code></pre><br><strong>如果f[i,k]=false 那么在 for j:=1 to n do 这个循环里f[i,j]将不会有变化</strong></p><p><strong>根据此发现，可以将其改成</strong></p><pre><code class="hljs delphi"><span class="hljs-keyword">for</span> k:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> f[i,k] <span class="hljs-keyword">then</span> <span class="hljs-comment">//优化</span>  <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>    f[i,j]:=f[i,j] <span class="hljs-keyword">or</span> f[k,j];</code></pre><p><strong>优化后的代码就能A本题了！</strong><br><strong>当然，本题的正解是Tarjan算法，用floyd只能算是侥幸</strong></p><h3 id="给出完整代码（Pascal"><a href="#给出完整代码（Pascal" class="headerlink" title="给出完整代码（Pascal):"></a>给出完整代码（Pascal):</h3><pre><code class="hljs delphi"><span class="hljs-keyword">var</span>  n,m,x,y,i,j,k:longint;  f:<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">1001</span>,<span class="hljs-number">0</span>..<span class="hljs-number">1001</span>] <span class="hljs-keyword">of</span> boolean;<span class="hljs-keyword">begin</span>  <span class="hljs-keyword">read</span>(n,m);  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> m <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span>    <span class="hljs-keyword">read</span>(x,y);f[x,y]:=true; <span class="hljs-comment">//用图的数据结构存储</span>  <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">for</span> k:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> f[i,k] <span class="hljs-keyword">then</span> <span class="hljs-comment">//优化</span>  <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span>    f[i,j]:=f[i,j] <span class="hljs-keyword">or</span> f[k,j];  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span> <span class="hljs-keyword">if</span> f[i,i] <span class="hljs-keyword">then</span> writeln(<span class="hljs-string">'T'</span>) <span class="hljs-keyword">else</span>  writeln(<span class="hljs-string">'F'</span>);<span class="hljs-keyword">end</span>.</code></pre>]]></content>
    
    
    <categories>
      
      <category>普及/提高-</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宁波-题解 P1942 4.取数游戏(Pascal)</title>
    <link href="/2020/06/06/nbP1942/"/>
    <url>/2020/06/06/nbP1942/</url>
    
    <content type="html"><![CDATA[<h1 id="取数游戏："><a href="#取数游戏：" class="headerlink" title="取数游戏："></a>取数游戏：</h1><p>仔细读题多遍后可以发现，四元组中的a,b,c,d=&gt;a=b<c=d=>设x=a，y=c，那么变成x&lt;y.</p><p>通过以上分析，可以联想到这题取得4个数必定是小=&gt;大，所以先从小到大排序。</p><p>再读题，可以发现四元组中a和b相等，c和d相等，推出至少要2个相同的数才有可能被选成符合题意的四元组。</p><p>加下来的部分有点复杂:设一个数的出现次数为x，由题意得在x中选2个数来做四元组中的前2个，使用排列组合公式:p(x,2)=x*(x-1)可求出在x中一共的选择方法。</p><p>Ps：这一步可以用最长平台来实现<br>示例代码:<br><pre><code class="hljs delphi">z:=<span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span> <span class="hljs-keyword">to</span> n+<span class="hljs-number">1</span> <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> a[i]=a[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> z:=z+<span class="hljs-number">1</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>    <span class="hljs-keyword">if</span> z&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span>  tot:=tot+<span class="hljs-number">1</span>;  b[tot]:=(z*(z-<span class="hljs-number">1</span>)) <span class="hljs-keyword">mod</span> p;<span class="hljs-keyword">end</span>;    z:=<span class="hljs-number">1</span>;  <span class="hljs-keyword">end</span>;</code></pre></p><p>至此，此题以完成一半，最后使用前缀和维护b数组<br>设最终答案为b[i]*(前i个b[i]的和) 2&lt;=i&lt;=n 原理的话就是排列组合（乘法原理）</p><p>最后附100pts代码<br><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> p=<span class="hljs-number">1000000007</span>;<span class="hljs-keyword">var</span>  a,b,s:<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">1000000</span>] <span class="hljs-keyword">of</span> int64;  ans:int64;  z,n,i,tot:longint;<span class="hljs-function"><span class="hljs-keyword">procedure</span> <span class="hljs-title">sort</span> <span class="hljs-params">(l,h:longint)</span>;</span>    <span class="hljs-keyword">var</span>        i,j,t,m:longint;    <span class="hljs-keyword">begin</span>        i:=l; j:=h; m:=a[(i+j)&gt;&gt;<span class="hljs-number">1</span>];        <span class="hljs-keyword">repeat</span>            <span class="hljs-keyword">while</span> a[i]&lt;m <span class="hljs-keyword">do</span> inc(i);        <span class="hljs-keyword">while</span> m&lt;a[j] <span class="hljs-keyword">do</span> dec(j);        <span class="hljs-keyword">if</span> i&lt;=j <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span>            t:=a[i]; a[i]:=a[j]; a[j]:=t;        inc(i); dec(j);        <span class="hljs-keyword">end</span>;        <span class="hljs-keyword">until</span> i&gt;j;        <span class="hljs-keyword">if</span> i&lt;h <span class="hljs-keyword">then</span> sort(i,h);        <span class="hljs-keyword">if</span> j&gt;l <span class="hljs-keyword">then</span> sort(l,j);    <span class="hljs-keyword">end</span>;<span class="hljs-keyword">begin</span>  <span class="hljs-keyword">read</span>(n);  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span> <span class="hljs-keyword">read</span>(a[i]);  sort(<span class="hljs-number">1</span>,n); z:=<span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span> <span class="hljs-keyword">to</span> n+<span class="hljs-number">1</span> <span class="hljs-keyword">do</span>    <span class="hljs-keyword">if</span> a[i]=a[i-<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> z:=z+<span class="hljs-number">1</span>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">begin</span>    <span class="hljs-keyword">if</span> z&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span>  tot:=tot+<span class="hljs-number">1</span>;  b[tot]:=(z*(z-<span class="hljs-number">1</span>)) <span class="hljs-keyword">mod</span> p;  s[tot]:=(s[tot-<span class="hljs-number">1</span>]+b[tot]) <span class="hljs-keyword">mod</span> p;<span class="hljs-keyword">end</span>;    z:=<span class="hljs-number">1</span>;  <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">2</span> <span class="hljs-keyword">to</span> tot <span class="hljs-keyword">do</span> ans:=(ans+(b[i]*s[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">mod</span> p) <span class="hljs-keyword">mod</span> p;  <span class="hljs-keyword">write</span>(ans);<span class="hljs-keyword">end</span>.</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>普及/提高-</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>宁波-题解 P1353 1．统计方格(Pascal)</title>
    <link href="/2020/06/06/nbP1352/"/>
    <url>/2020/06/06/nbP1352/</url>
    
    <content type="html"><![CDATA[<p>说实话这题是真的水<br>最多算个入门<br>题目这么长其实可以总结成一下:</p><p><strong>在一个n*m的01方格里，统计0的个数，以及0最多和最少的行</strong></p><p>没话了。。<br>看代码吧<br><pre><code class="hljs pascal"><span class="hljs-keyword">var</span>  n,m,i,j,x,ans,mx,mn,mxi,mni:longint;  k:<span class="hljs-keyword">array</span>[<span class="hljs-number">0</span>..<span class="hljs-number">10000</span>] <span class="hljs-keyword">of</span> longint;<span class="hljs-keyword">begin</span>  readln(n,m);  mx:=-maxlongint; mn:=maxlongint; <span class="hljs-comment">//初始化</span>  <span class="hljs-keyword">for</span> i:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> n <span class="hljs-keyword">do</span> <span class="hljs-keyword">begin</span>    <span class="hljs-keyword">for</span> j:=<span class="hljs-number">1</span> <span class="hljs-keyword">to</span> m <span class="hljs-keyword">do</span>  <span class="hljs-keyword">begin</span>    <span class="hljs-keyword">read</span>(x);<span class="hljs-keyword">if</span> x=<span class="hljs-number">0</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> inc(k[i]); inc(ans); <span class="hljs-keyword">end</span>; <span class="hljs-comment">//k[i]=一行中0的个数;ans=0的总个数</span>  <span class="hljs-keyword">end</span>;<span class="hljs-keyword">if</span> k[i]&gt;mx <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> mx:=k[i]; mxi:=i; <span class="hljs-keyword">end</span>; <span class="hljs-comment">//更新最大值</span><span class="hljs-keyword">if</span> k[i]&lt;mn <span class="hljs-keyword">then</span> <span class="hljs-keyword">begin</span> mn:=k[i]; mni:=i; <span class="hljs-keyword">end</span>; <span class="hljs-comment">//更新最小值</span>readln;  <span class="hljs-keyword">end</span>;  <span class="hljs-keyword">write</span>(ans,<span class="hljs-string">' '</span>,mxi,<span class="hljs-string">' '</span>,mni); <span class="hljs-comment">//输出</span><span class="hljs-keyword">end</span>.</code></pre></p>]]></content>
    
    
    <categories>
      
      <category>入门</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
